<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc [
<!ENTITY nbsp    "&#160;">
<!ENTITY zwsp   "&#8203;">
<!ENTITY nbhy   "&#8209;">
<!ENTITY wj     "&#8288;">
]>
<?xml-model href="rfc7991bis.rnc"?>
<rfc
        xmlns:xi="http://www.w3.org/2001/XInclude"
        docName="draft-ietf-opsawg-collected-data-manifest-05"
        category="std"
        ipr="trust200902"
        obsoletes=""
        updates=""
        submissionType="IETF"
        xml:lang="en"
        tocInclude="true"
        sortRefs="true"
        symRefs="true"
        version="3" >
  <front>
    <title abbrev="Telemetry Data Manifest">A Data Manifest for Contextualized Telemetry Data</title>
    <seriesInfo name="Internet-Draft" value="draft-ietf-opsawg-collected-data-manifest-05"/>
    <author fullname="Benoit Claise" initials="B" surname="Claise">
      <organization>Huawei</organization>
      <address>
        <email>benoit.claise@huawei.com</email>
      </address>
    </author>
    <author fullname="Jean Quilbeuf" initials="J" surname="Quilbeuf ">
      <organization>Huawei</organization>
      <address>
        <email>jean.quilbeuf@huawei.com</email>
      </address>
    </author>
    <author fullname="Diego R. Lopez" initials="D" surname="Lopez ">
      <organization>Telefonica I+D</organization>
      <address>
        <postal>
          <street>Don Ramon de la Cruz, 82</street>
          <city>Madrid  28006</city>
          <country>Spain</country>
        </postal>
        <email>diego.r.lopez@telefonica.com</email>
      </address>
    </author>
    <author fullname="Ignacio Dominguez" initials="I" surname="Dominguez">
      <organization>Telefonica I+D</organization>
      <address>
        <postal>
          <street>Ronda de la Comunicacion, S/N</street>
          <city>Madrid  28050</city>
          <country>Spain</country>
        </postal>
        <email>ignacio.dominguezmartinez@telefonica.com</email>
      </address>
    </author>
    <author fullname="Thomas Graf" initials="T. " surname="Graf">
      <organization>Swisscom</organization>
      <address>
        <postal>
          <street>Binzring 17</street>
          <city>Zurich</city>
          <code>8045</code>
          <country>Switzerland</country>
        </postal>
        <email>thomas.graf@swisscom.com</email>
      </address>
    </author>
    <date/>
    <area>OPS</area>
    <workgroup>OPSAWG</workgroup>
    <abstract>
      <t>
        Network platforms use Model-driven Telemetry, and in particular YANG-Push, to continuously stream information, including both counters and state information.
        This document documents the metadata that ensure that the collected data can be interpreted correctly.
        This document specifies the Data Manifest, composed of two YANG data models (the Platform Manifest and the Data Collection Manifest).
        These YANG modules are specified at the network (i.e. controller) level to provide a model that encompasses several network platforms.
        The Data Manifest must be streamed and stored along with the data, up to the collection and analytics system in order to keep the collected data fully exploitable by the data scientists.
      </t>
    </abstract>
  </front>
  <middle>
    <section anchor="intro">
      <name>Introduction</name>
      <t>
        Network platforms use Model-driven Telemetry (MDT), and in particular YANG-Push <xref target="RFC8641"/>, to continuously stream information, including both counters and state information.
      </t>
      <t>
        This document specifies what needs to be kept as metadata (i.e., the Data Manifest) to ensure that the collected data can still be interpreted correctly throughout the collection and network analytics toolchain. When streaming YANG-structured data with YANG-Push <xref target="RFC8641"/>, there is a semantic definition in the corresponding YANG module definition.
        This is the semantic information for the collected data nodes: While this semantic is absolutely required to correctly decode and interpret the data, understanding the network platform and collection environment contexts information is equally important to interpret the data.
      </t>
      <t>
        This document proposes the Data Manifest, which is composed of two YANG data models, namely, the Platform Manifest and the Data Collection Manifest, in order to keep the collected data exploitable by the data scientists.
      </t>
      <t>
        The Platform Manifest contains information characterizing the platform streaming the telemetry information, while the the Data Collection Manifest contains the required information to characterize how and when the telemetry information was metered.
      </t>
      <t>         
        The two proposed YANG modules in the Data Manifest do not expose many new information but rather define what should be exposed by a platform streaming or storing telemetry data.
        Some related YANG modules have been specified to retrieve the platform capabilities:
      </t>
      <ul>
        <li>
          The IETF YANG Library <xref target="RFC8525"/>.
        </li>
        <li>
          YANG Modules Describing Capabilities for Systems and Datastore Update Notifications <xref target="RFC9196"/> for the platform capabilities regarding the production and export of telemetry data.
        </li>
        <li>
          <xref target="I-D.claise-netconf-metadata-for-collection"/>, which is based on the previous draft to define the optimal settings to stream specific items (i.e., per path).
        </li>
      </ul>
      <t>
        These related YANG modules are important to discover the capabilities before applying the telemetry configuration (such as on-change). Some of their content is part of the context for the streamed data.
      </t>
      <t>
        This documents covers only metadata about the collection context for the telemetry.
        The collected data is likely to be transformed into usable indicators for the network.
        The list of such transformation operation applied to the data is often called data lineage.
        Supplying the data lineage for the computed indicators is out of scope of this document.
      </t>
      <t>
        We first present the module for the Platform Manifest in <xref target="platform-manifest"/> and then the module for the Data Collection Manifest in <xref target="data-collection-manifest"/>. The full Data Manifest is obtained by combining these two modules. We explain in <xref target="mapping"/> how the Data Manifest can be retrieved and how collected data is mapped to the Data Manifest.
      </t>

      <section anchor="use-cases">
        <name>Use Cases</name>
    
         <section anchor="network-analytics">
           <name>Network Analytics</name>
           <t>
            Streamed information from network platforms is used for network analytics, incident detections, and in the end closed-loop automation. This streamed data can be stored in a database (sometimes called a big data lake) for further analysis.
          </t>
          <t>         
            As an example, a database could store a time series representing the evolution of a specific counter collected from a network platform. When analyzing the data, the network operator/data scientist must understand the context information for these data:
          </t>
           <ul>
             <li>
               This counter definition in the YANG model.
             </li>
             <li>
               The network platform specific vendor, model, and OS.
             </li>
             <li>
               The collection parameters.
             </li>
           </ul>
           <t>
              Characterizing the source used for producing the data (vendor, platform, and OS) is useful to complement the data.  As an example, knowing the exact data source software specification might reveal a particularity in the observed data, explained by a specific bug, a specific bug fix, or simply a particular specific behavior.  This is also necessary to ensure the reliability of the collected data. On top of that, in particular for YANG-Push <xref target="RFC8641"/>, it is crucial to know the set of YANG modules supported by the platform, along with their deviations. In some cases, there might even be some backwards incompatible changes in native modules between one OS version to the next one.  This information is captured by the proposed Platform Manifest.
          </t>
           <t>
              From a collection parameters point of view, the data scientists analyzing the collected data must know that the counter was requested from the network platform as on-change or at specific cadence. Indeed, an on-change collection explains why there is a single value as opposed to a time series. In case of periodic collection, this exact cadence might not be observable in the time series. Indeed, this time series might report some values as 0 or might even omit some values. The reason for this behavior might be diverse: the network platform was under stress, with a too small observation period, compared to the minimum-observed-period <xref target="I-D.claise-netconf-metadata-for-collection"/>. Again, knowing the conditions under which the counter was collected and streamed (along with the platform details) help drawing the right conclusions. As an example, taking into account the value of 0 might lead to a wrong conclusion that the counter dropped to zero. This document specifies the Data Collection Manifest, which contains the required information to characterize how and when the telemetry information was metered.
          </t>
           <t>
              The goal of the current document is to define what needs to be kept as metadata (i.e., the Data Manifest) to ensure that the collected data can still be interpreted correctly. 
          </t>
         </section>

         <section anchor="new-device-onboarding">
           <name>New Device Onboarding</name>
           <t>
              When a new device is onboarded,  operators must make sure that the new device streams data with YANG-Push, that the telemetry data is the right ones, that the data is correctly ingested in the collection system, and finally that the data can be analyzed (compared with other similar devices). For the last point, the Data Manifest, which must be linked to the data up to the collection and analytics system, contains all the relevant information.
          </t>
         </section>

        <section anchor="data-mesh-principles-in-networking" >
          <name>Data Mesh Principles in Networking</name>
          <t>         
             The concept behind the data mesh <eref target="https://www.datamesh-architecture.com/"/> are:
          </t>
          <ul>
            <li>
              Principle of Domain Ownership: Architecturally and organizationally align business, technology, and analytical data, following the line of responsibility. Here, the Data Mesh principles adopt the boundary of bounded context to individual data products where each domain is responsible for (and owns) its data and models.
            </li>
            <li>
              Principle of Data as a Product: The “Domain” owners are responsible to provide the data in useful way (discoverable through a catalog, addressable with a permanent and unique address, understandable with well defined semantics, trustworthy and truthful, self-describing for easy consumption, interoperable by supporting standards, secure, self-contained, etc.) and should treat consumers of that data as customers. It requires and relies on the “Domain Ownership” principle.
            </li>
            <li>
              Principle of Self-serve Data Platform: This fosters the sharing of cross-domain data in order to create extra value.
            </li>
            <li>
              Principle of Federated Computational Governance: Describes the operating model and approach to establishing global policies across a mesh of data products.
            </li>
          </ul>
          <t>
            The most relevant concept for this document is the "Data as a Product" principle. The Data Manifest fulfills this principle as the two YANG data models, Platform Manifest and the Data Collection Manifest, along with the data, provide all the necessary information in a self-describing way for easy consumption.
          </t>
         </section>

      </section>
    </section>

    <section anchor="terminology">
      <name>Terminology </name>
      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
        NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
        "MAY", and "OPTIONAL" in this document are to be interpreted as
        described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
        when, and only when, they appear in all capitals, as shown here.
      </t>
      <t>
        Data Manifest: all the necessary data required to interpret the telemetry information.
      </t>
      <t>
        Platform Manifest: part of the Data Manifest that completely characterizes the platform producing the telemetry information
      </t>
      <t>
        Data Collection Manifest: part of the Data Manifest that completely characterizes how and when the telemetry information was metered.
      </t>
    </section>
    <section anchor="platform-manifest">
      <name>Platform Manifest</name>
        <section anchor="platform-manifest-model-tree">
          <name>Overview of the Model</name>
          <t>
            <xref target="platform-manifest-tree"/> contains the YANG tree diagram <xref target="RFC8340"/> of the ietf-platform-manifest module.
            The tree diagram is obtained by reusing existing modules, such as ietf-yang-library <xref target="RFC8525"/> using the YANG mount mechanism <xref target="RFC8528"/>.
            Additionally to the YANG module in <xref target="platform-manifest-model"/>, we specify the YANG-library instance to be mounted.
            We explain in <xref target="schema-mount-version"/> how the YANG tree is obtained.
          </t>
          <figure anchor="platform-manifest-tree">
            <name>YANG tree diagram for ietf-platform-manifest module</name>
            <artwork type="ascii-art"><![CDATA[
{{platform_manifest_tree}}
            ]]></artwork>
          </figure>
        <t>
          The YANG module actually contains a list of Platform Manifests (in 'platforms/platform'), indexed by the identifier of the platform.
          That identifier should be defined by the network manager so that each platform has a unique id.
          There are several ongoing drafts about managing the inventory of the network <xref target="I-D.ietf-ivy-network-inventory-yang"/>, <xref target="I-D.havel-nmop-digital-map"/> based on <xref target="RFC8345"/>.
          The platform-id should be the same as the identifier used in these drafts or the node id in <xref target="RFC8345"/>.
          As an example, the identifier could be the 'sysname' from the ietf-notification module presented in <xref target="I-D.tgraf-netconf-notif-sequencing"/>.
          The scope of this module is the scope of the data collection, i.e. a given network, therefore it contains a collection of Platform Manifests, as opposed to the device scope, which would contain a single Platform Manifest.
        </t>

        <t>
          The Platform Manifest is identified by a set of parameters ('name', 'software-version', 'software-flavor', 'os-version', 'os-type') that are aligned with the YANG Catalog <eref target="www.yangcatalog.org"/> <xref target="I-D.clacla-netmod-model-catalog"/> so that the YANG Catalog could be used to retrieve the YANG modules a posteriori.
          The vendor of the platform can be identified via its name 'vendor' or its PEN number 'vendor-pen', as described in <xref target="RFC9371"/>.
        </t>
        <t>
          The Platform Manifest also includes the contents of the YANG Library <xref target="RFC8525"/>.
          That module set is particularly useful to analyze the xpath filters, as they are based on module names (see <xref target="RFC8639"/>, page 47).
        </t>
        <t>
          The Platform Manifest is obtained by specifying the new fields defined above and mounting the YANG library module, along with the YANG Revisions augmentations.
          Thus, the YANG Library part is not repeated in the YANG module for the Platform Manifest.
        </t>
      </section>
      <section anchor="platform-manifest-model">
        <name>YANG module ietf-platform-manifest</name>
        <t>
          We provide in this Section the code of the ietf-platform manifest YANG module.
          Additionally, we provide the extension data file for YANG schema mount.
          The platform manifest MUST conform to the model obtained by combining these two specifications.

        </t>
        <sourcecode name="ietf-platform-manifest@2024-07-02.yang" type="yang" markers="true"><![CDATA[
{{platform_schema_mount}}
            ]]>
        </sourcecode>
        <sourcecode anchor="platform-extension-data" name="platform-extension-data.xml" type="xml" markers="true"><![CDATA[
{{platform_extension_data}}
]]>
        </sourcecode>

      </section>
    </section>

     <section anchor="data-collection-manifest">
       <name>Data Collection Manifest</name>
        <section anchor="model-tree">
          <name>Overview of the Model</name>
          <t>
            <xref target="data-collection-manifest-tree"/> contains the YANG tree diagram <xref target="RFC8340"/> of the ietf-data-collection-manifest module.
            The module relies on the YANG Schema mount <xref target="RFC8528"/> to reuse existing YANG modules describing the current data collection status.
            We explain in <xref target="schema-mount-version"/> how the YANG tree is obtained.
          </t>
          <figure anchor="data-collection-manifest-tree">
            <name>YANG tree diagram for ietf-data-collection-manifest module</name>
            <artwork type="ascii-art"><![CDATA[
{{data_collection_manifest_tree}}
              ]]></artwork>
          </figure>
          <t>
            The 'data-collections' container contains the information related to each YANG-Push subscription.
            As for the Platform Manifest, these subscriptions are indexed by the platform id, so that all subscriptions in the network can be represented in the module.
          </t>
          <t>
            As most of the information related to YANG-push subscription
            <xref target="RFC8639"/> and <xref target="RFC8641"/> is stored in the ietf-yang-push model, we mount these modules.
            These modules have a part common to all subscriptions of the platform, stored in the 'streams' and 'filters' container.
            The information about subscriptions themselves are stored in the 'subscriptions/subscription' list, indexed by subscription id.
          </t>
          <t>
            In the subscription object, the 'current-period' indicates the period currently used between two updates.
            That leaf can only be present when the subscription is periodic.
            The current period might differ from the requested period if the platform implements a mechanism to increase the collection period when it is overloaded.
            Having the current period information is crucial to understand if telemetry is missing because of a bug or a packet loss or simply because it was dynamically adjusted by the platform.
          </t>
          <t>
            The current-period node is added by the module 'ietf-data-collection-manifest-statistics' presented in <xref target="data-manifest-statistics-module"/>.
            This module augments the subscription list from the module 'ietf-subscribed-notifications'.
            It is mounted as well via the YANG Schema Mount mechanism.
            The module for the Data Collection Manifest is presented in <xref target="module-code"/>.
          </t>
        </section>
       <section anchor="data-manifest-statistics-module">
         <name>YANG module ietf-data-collection-manifest-statistics</name>
         <t>
           Below is the code of the ietf-data-collection-manifest-statistics module, which augments the ietf-subscribed-notification modules to provide information needed for the Data Collection Manifest.
         </t>
         <sourcecode name="ietf-data-collection-manifest-statistics@2024-07-02.yang" type="yang" markers="true"><![CDATA[
{{data_collection_manifest_statistics}}
    ]]>
         </sourcecode>
       </section>
       <section anchor="module-code">
         <name>YANG module ietf-data-collection-manifest</name>
         <t>
           We provide in this Section the code of the ietf-data-collection-manifest YANG module.
           Additionally, we provide the extension data file for YANG schema mount.
           The Data Collection Manifest MUST conform to the model obtained by combining these two specifications.
         </t>
         <sourcecode name="ietf-data-collection-manifest@2024-07-02.yang"
                     type="yang" markers="true"><![CDATA[
{{data_collection_manifest_yang}}
    ]]>
         </sourcecode>
         <sourcecode anchor="data-collection-extension-data" name="data-collection-extension-data.xml" type="xml" markers="true"><![CDATA[
{{data_extension_data}}
]]>
         </sourcecode>

      </section>
    </section>
    <section anchor="mapping" >
      <name>Data Manifest and the Collected Data</name>
      <section anchor="collecting_dm">
        <name>Collecting the Data Manifest</name>
      <t>
          The Data Manifest MUST be streamed and stored along with the collected data.
          In case the collected data are moved to a different place (typically a database), the Data Manifest MUST follow the collected data.
          This can render the collected data unusable if that context is lost, for instance when the data is stored without the relevant information.
          The Data Manifest MUST be updated when the Data Manifest information changes, for example, when a router is upgraded, when a new telemetry subscription is configured, or when the telemetry subscription parameters change.
          The Data Manifest can itself be considered as a time series, and stored in a similar fashion to the collected data.
      </t>
       <t>
          The collected data should be mapped to the Data Manifest. Since the Data Manifest will not change as frequently as the collected data itself, it makes sense to map several data to the same Data Manifest. Somehow, the collected data must include a metadata pointing to the corresponding Data Manifest. In case of Data Manifest change, the system should keep the mapping between the data collected so far and the old Data Manifest, and not assume that the latest Data Manifest is valid for the entire time series.
       </t>
       <t>
          The Platform Manifest is likely to remain the same until the platform is updated. Thus, the Platform Manifest only needs to be collected once per streaming session and updated after a platform reboot.
       </t>
        <t>
          Similarly, the elements common to all subscriptions, such as the stream definitions and the common filters might be updated less frequently than the subscriptions.
        </t>
        <t>
          As this draft specifically focuses on giving context on data collected via streamed telemetry, we can assume that a streaming telemetry system is available.
          Retrieving the Data Collection Manifest and Platform Manifest can be done either by reusing that streaming telemetry system (in-band) or using another system (out-of-band), for instance by adding headers or saving manifests into a YANG instance file <xref target="RFC9195"/>.
        </t>
        <t>
          We propose to reuse the existing telemetry system (in-band approach) in order to lower the efforts for implementing this draft.
          To enable a platform supporting streaming telemetry to also support the Data Manifest, it is sufficient that this platform supports
          the models from <xref target="platform-manifest"/> and <xref target="data-collection-manifest"/>.
          Recall that each type of manifest has its own rough frequency update, i.e. at reboot for the Platform Manifest and at new subscription or CPU load variation for the Data Collection Manifest.
          The Data Manifest MUST be streamed with the YANG-Push on-change feature <xref target="RFC8641"/> (also called event-driven telemetry).
          <xref target="inband-example"/> shows how the in-band approach would work while storing to a time-series database (TSDB).
        </t>
        <t>
          The underlying time series database should accommodate the various rates at which different part of the Data Manifest are updated.
          In particular, storing the Platform Manifest should be optimized to avoid duplicating repeated content and only storing a new version when there is a change in the manifest.
        </t>
      </section>

      <section anchor="mapping_dm">
        <name>Mapping Collected Data to the Data Manifest</name>
        <t>
          With YANG-push, each notification sent by the device is part of a subscription, which is also one of the YANG keys used to retrieve the Data Manifest, the other key being the platform ID.
          In order to enable a posteriori retrieval of the Data Manifest associated to a datapoint, the collector must:
        </t>
        <ul>
          <li>Keep the subscription id and platform id in the metadata of the collected values</li>
          <li>Collect as well the Data Manifest for the subscription associated to the datapoint.</li>
        </ul>
        <t>
          With this information, to retrieve the Data Manifest from the datapoint, the following happens:
        </t>
        <ul>
          <li>The subscription id and platform id are retrieved from the datapoint metadata</li>
          <li>The Data Manifest for that datapoint is obtained by using the values above as keys.</li>
        </ul>
        <t>
          We don’t focus on the timing aspect as storing both the data and their manifest in a time series database (TSDB) will allow the data scientists to look for the Data Manifest corresponding to the timestamp of the datapoint.
          More precisely, given the timestamp of a collected datapoint, the query to the TSDB would be to get the last version of the Data Manifest before that timestamp.
          In that scenario, the reliability of the collection of the Data Manifest is the same as the reliability of the data collection itself, since the Data Manifest is like any other data.
        </t>
      </section>

      <section anchor="operational-considerations">
        <name>Operational Considerations</name>
         <t>
             It is expected that the Data Manifest is streamed directly from the network equipment, along with YANG-Push  <xref target="RFC8641"/> data. However, if the network equipment streaming telemetry does not support yet the YANG modules from the Data Manifest specified in this document, the telemetry collector could populate the Data Manifest from available information collected from the platform. However, this option requires efforts on the telemetry collector side, as the information gathered in the Data Manifest proposed in this document could be scattered among various standard and vendor- specific YANG modules <xref target="RFC8199"/>, that depend on the platform.
         </t>
         <t>
             That Data Manifest should be kept and available even if the source platform is not accessible (from the collection system), or if the platform has been updated (new operating system or new configuration). The Platform Manifest is "pretty" stable and should change only when the platform is updated or patched. On the other hand, the Data Collection Manifest is likely to change each time a new YANG-Push subscription <xref target="RFC8641"/> is requested and might even change if the platform load increases and collection periods are updated. To separate these two parts, we enclose each of them in its own module.
         </t>
      </section>
    </section>
    <section anchor="example">
      <name>Example</name>
      <t>
        Below is an example of both a Platform manifest and corresponding Data Collection Manifests.
        The list of YANG modules in the yang-library container is kept empty for brevity.
      </t>
      <t>&lt;CODE BEGINS&gt; file "manifests-example.json"</t>
      <figure>
        <artwork><![CDATA[
{{data_collection_manifest_example}}
  ]]></artwork>
      </figure>
      <t>&lt;CODE ENDS&gt;</t>
      <t>
        The file above contains the Data Collection Manifest for two XPaths subscriptions.
        With the Data Collection Manifest for the first one, with subscription id 4242, the exact semantics of the collected path, here the administrative status of the network interfaces, can be obtained by looking up the module in the yang-library of the corresponding Platform Manifest, in order to obtain the exact revision of ietf-interfaces used at collection time.
        Also, the "on-change" container indicates that data will be sent only if there is a change, thus not receiving data indicates that the administrative status of the interface did not change.
      </t>
      <t>
        The other example of Data Collection Manifest, with subscription id 4243, shows how a periodic subscription is reported.
        In that example, the current-period indicates that the requested period of 10s (1000 centiseconds) could not be attained and is now of 20s, for instance because the device is overloaded.
      </t>

    </section>
    <section anchor="security">
      <name>Security Considerations</name>
      <t>
        As we are reusing an existing telemetry system, the security considerations lies with the new content divulged in the new manifests.
        Appropriate access control must be associated to the corresponding leafs and containers.
      </t>
      <t>
        The integrity and provenance of the data of the collection manifest can be ensured by a signing mechanism such as <xref target="I-D.lopez-opsawg-yang-provenance"/>.
      </t>
    </section>
    <section anchor="iana">
      <name>IANA Considerations</name>
      <t>
        This document includes no request to IANA.
      </t>
    </section>
    <section>
      <name>Contributors</name>
    </section>
    <section>
      <name>Open Issues</name>
        <ul>
          <li>
            Do we want to handle the absence of values, i.e. add information about missed collection or errors in the collection context ? It could also explain why some values are missing. On the other hand, this might also be out scope.
            CLOSED: the goal of the manifest is to be able to detect miscollection a posteriori.
            Assurance of the metric collection is out of scope and could be
            done via an external mechanism such as SAIN.
          </li>
          <li>
            Henk: how does this interact with SBOM effort?
            CLOSED: SBOM is another kind of manifest, we are focusing here on data collection.
          </li>
          <li>
            What is the link with the RFC8345 NodeId and IVY?
            CLOSED: added text.
          </li>
          <li>
            Handling of deletion in <xref target="I-D.kll-yang-label-tsdb"/>.
          </li>
        </ul>
    </section>
  </middle>
  <back>
    <references title="Normative References">
      <xi:include href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
      <xi:include href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
      <xi:include href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.8340.xml"/>
      <xi:include href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.8525.xml"/>
      <xi:include href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.8639.xml"/>
      <xi:include href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.8641.xml"/>
      <xi:include href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.9195.xml"/>
    </references>
    <references title="Informative References">
      <xi:include href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.8199.xml"/>
      <xi:include href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.8343.xml"/>
      <xi:include href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.8345.xml"/>
      <xi:include href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.8528.xml"/>
      <xi:include href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.9196.xml"/>
      <xi:include href="http://xml.resource.org/public/rfc/bibxml/reference.RFC.9371.xml"/>
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.draft-clacla-netmod-model-catalog-03"/>
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.draft-claise-netconf-metadata-for-collection-02"/>
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.tgraf-netconf-notif-sequencing.xml"/>
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.lopez-opsawg-yang-provenance.xml"/>
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.kll-yang-label-tsdb.xml"/>
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-ivy-network-inventory-yang.xml"/>
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml3/reference.I-D.havel-nmop-digital-map.xml"/>
    </references>
    <?rfc needLines="100"?>
    <section anchor="inband-example">
      <name> title="Example of use based on MDT</name>
      <t>
        In this example, the goal is to collect the administrative status and number of received bytes for the interfaces of a fictional ACME device, and store the result in a time-series database (TSDB).
        The metrics are collected via YANG-Push, which is configured by specifying their XPaths and when they should be collected (periodically or on-change).
        More precisely, we want collect "ietf-interfaces:interfaces/interface/enabled" on every change and "ietf-interfaces:interfaces/interface/statistics/in-octets" every 100 milliseconds.
        The paths here are referring to the YANG module from <xref target="RFC8343"/>.
        The configuration of YANG push is out of scope for this document.
        Since they don’t have the same trigger, each of the path must be collected in its own subscription.
        <xref target="collection_example"/> presents an example for such a collection.
      </t>
      <figure anchor="collection_example">
        <name>Example of collection from a device to a TSDB</name>
        <artwork type="ascii-art"><![CDATA[
     +------------+                +--------+
     |   MDT      |--------------> |  TSDB  |
     | Collector  |                +--------+
     +------------+
          ^
          |
          |
      +---------+
      | Device  |
      +---------+
          ]]></artwork>
      </figure>
      <t>
        In the scenario from <xref target="collection_example"/>, the collector receives YANG-push from the device and stores it into a TSDB.
        We first present a version without Data Manifest and then how to enrich it with the Data Manifest.
      </t>
      <t>
        We use the notation from <xref target="I-D.kll-yang-label-tsdb"/> to represent how the data is stored in the TSDB.
        Without the data manifest, the result of the collection would be stored as showed in <xref target="influx_before"/>.
        The "host" label indicates the devices from which the data is collected and the YANG keys are included as well.
        Here the interface "eth0" is enabled and received 1234 octets.
        In that case, the value is stored, without any way to know how the value was obtained.
      </t>
      <figure anchor="influx_before">
          <name>Storing datapoints without Data Manifest</name>
          <artwork type="ascii-art"><![CDATA[
 * Metric: interfaces_interface_enabled
 * Value: True
 * Labels:
   - host: "PE1"
   - interfaces_interface_name: "eth0"
--
 * Metric: interfaces_interface_statistics_in_octets
 * Value: 1234
 * Labels:
   - host: "PE1"
   - interfaces_interface_name: "eth0"
          ]]></artwork>
      </figure>
      <t>
        A possibility for keeping the Data Manifest with the data is to store it directly into the TSDB.
        In that case, the collector can subscribe to the data exported by the module presented in this draft and store it as other metrics.
        For the Platform Manifest, assuming the platform ID is "PE1", the collector subscribes to the path "ietf-platform-manifest:platforms/platform[id=PE1]".
        For the Data Collection Manifests, the collector subscribes to the path "ietf-data-collection-manifest:data-collections/data-collection[platform-id="PE1"]/yang-push-collection/subscriptions/subscription[id=X]" where X is the subscription id of existing subscriptions.
        With the approach from <xref target="I-D.kll-yang-label-tsdb"/>, the corresponding subtrees would be split into a set of datapoints, one per leaf.
        <xref target="influx_manifest"/> shows two examples of storing leaves in a TSDB.
        The first leaf is the vendor PEN number, which is part of the Platform Manifest.
        The second leaf is the Xpath filter used for subscription to the interface status.
      </t>
      <figure anchor="influx_manifest">
        <name>Example of storing Platform and Data Collection Manifest: Vendor PEN and Xpath filter.</name>
        <artwork><![CDATA[
 * Metric: platforms_platform_vendor_pen
 * Value: 32473
 * Labels:
   - host: "PE1"
   - platforms_platform_id: "PE1"
--
 * Metric: data_collections_data_collection_yang_push_collection_
           subscriptions_subscription_datastore_xpath_filter
 * Value: "ietf-interfaces:interfaces/interface/enabled"
 * Labels:
   - host: "PE1"
   - data_collections_data_collection_platform_id: "PE1"
   - data_collections_data_collection_yang_push_collection_
     subscriptions_subscription_id: 4242
         ]]></artwork>
      </figure>
      <t>
          In the labels, the "host" might be different from the "platforms_platform_id" in case the collector is the one assembling it, i.e. for devices that do not natively support the Data Manifest.
          In that case, the value of this label could be the hostname of the collector.
          The host value does not matter for retrieving the Data Manifest as the platform id is the meaningful field.
      </t>
      <t>
        In our example, we can retrieve the Platform Manifest associated to a collected datapoint by looking for datapoints that have the label "platforms_platform_id" equal to the value of the host for that collected datapoint.
        In order to link a datapoint with the corresponding Data Collection Manifest, we need to add an additional label for the subscription id.
        For instance, the same datapoints as in <xref target="influx_before"/> could be stored as in <xref target="influx_after"/>.
      </t>
      <figure anchor="influx_after">
        <name>Storing datapoints with information to retrieve the Data Manifest</name>
        <artwork type="ascii-art"><![CDATA[
 * Metric: interfaces_interface_enabled
 * Value: True
 * Labels:
   - host: "PE1"
   - interfaces_interface_name: "eth0"
   - data_collections_data_collection_yang_push_subscriptions_
     subscription_id: 4242
--
 * Metric: interfaces_interface_statistics_in_octets
 * Value: 1234
 * Labels:
   - host: "PE1"
   - interfaces_interface_name: "eth0"
   - data_collections_data_collection_yang_push_subscriptions_
     subscription_id: 4243
          ]]></artwork>
      </figure>
      <t>
        From the "interfaces_interface_enabled" datapoint, one can retrieve the corresponding Data Collection Manifest by looking for datapoints that have the label data_collections_data_collection_yang_push_collection_subscriptions_subscription_id equal to 4242.
      </t>
      <t>
        Various optimizations could be done, such as relying on on-change subscription to modify only the leaves that changed.
        In that way, the amount of data needed for updating and storing the Data Manifest in the TSDB would be limited.
      </t>

    </section>
    <section>
      <name>Changes between revisions</name>
      <t>v04 -> v05 </t>
      <ul>
        <li>Remove references to full-include draft, use schema mount.</li>
        <li>Explain link with schema node id</li>
      </ul>
      <t>v03 -> v04 </t>
        <ul>
          <li>State that data lineage is out of scope</li>
          <li>Replace copy-pasted version of the modules with schema mount version, use full-embed for the "real" one</li>
          <li>Schema mount version is the fallback plan if full:embed is not there fast enough.</li>
          <li>Update examples accordingly</li>
        </ul>
      <t>v02 -> v03 </t>
        <ul>
          <li>Explicit that modules are network (Controller) level</li>
          <li>InfluxDB example changed to TSDB example aligned with <xref target="I-D.kll-yang-label-tsdb"/></li>
          <li>Minor edits i.e. network element -> platform , object -> data node</li>
        </ul>
      <t> v01 -> v02 </t>
        <ul>
          <li>Updated example with latest version of the model.</li>
        </ul>
      <t>
          v00 (WG adoption) - v01
      </t>
          <ul>
            <li>Solve integrity issue by delegating to <xref target="I-D.lopez-opsawg-yang-provenance"/>.</li>
          </ul>
      <t>
        v05 -> v06
      </t>
        <ul>
          <li> Remove YANG packages </li>
          <li> Switch YANG models from device view to network view </li>
          <li> Add PEN number to identify vendors </li>
          <li> Intro rewritten with uses cases</li>
          <li> Added an "Operational Considerations" section </li>
          <li> Switch from MDT to YANG-push</li>
        </ul>
      <t>
        v04 -> v05
      </t>
        <ul>
          <li> First version of example scenario</li>
          <li> Updated affiliation</li>
          <li> Updated YANG module names to ietf-platform-manifest and ietf-data-collection-manifest </li>
          <li> Unify used terms as defined in the terminology section</li>
          <li> Replaced 'device' with 'platform' </li>
          <li> Split Section 5 into two sections for better readibility</li>
        </ul>
      <t>
        v03 -> v04
      </t>
        <ul>
          <li> Fix xym error</li>
          <li> Moved terminology after introduction</li>
          <li> Clarified the role of the module</li>
        </ul>
      <t>
        v02 -> v03
      </t>
        <ul>
          <li> Add when clause in YANG model</li>
          <li> Fix validation errors on YANG modules</li>
          <li> Augment YANG library to handle semantic versioning</li>
        </ul>
      <t>
        v01 -> v02
      </t>
        <ul>
          <li> Alignment with YANGCatalog YANG module: name, vendor </li>
          <li> Clarify the use of YANG instance file </li>
          <li> Editorial improvements </li>
        </ul>
      <t>
        v00 -> v01
      </t>
        <ul>
          <li> Adding more into data platform: yang packages, whole yanglib module to specify datastores </li>
          <li> Setting the right type for periods: int64 -> uint64 </li>
          <li> Specify the origin datastore for mdt subscription </li>
          <li> Set both models to config false </li>
          <li> Applying text comments from Mohamed Boucadair </li>
          <li> Adding an example of data-manifest file </li>
          <li> Adding rationale for reusing telemetry system for collection of the manifests </li>
          <li> Export manifest with on change telemetry as opposed to YANG instance file </li>
        </ul>
      <t>
        v00
      </t>
          <ul>
          <li> Initial version </li>
        </ul>
    </section>
    <section anchor="schema-mount-version">
      <name>Generating YANG Tree Diagrams</name>
      <t>
        This section provides the files needed to generate the YANG tree diagrams <xref target="RFC8340"/> from <xref target="platform-manifest-tree"/> and <xref target="data-collection-manifest-tree"/>.
        The diagrams were obtained using yanglint <eref target="https://github.com/CESNET/libyang"/> version 2.1.80, using the YANG Schema Mount <xref target="RFC8528"/>.
        They were manually edited to remove parts irrelevant to this document such as data nodes from imported modules, notifications and RPCs.
      </t>
      <t>
        In order to get a tree diagram involving YANG Schema Mount with yanglint, two data files are required, in addition to the YANG module, its dependencies and the YANG modules to be mounted.
        First we need the extension data, containing the YANG library to use at the mount point.
        Then we need the YANG library to use at the top-level context.
        We provide below the commands used to get the "raw" YANG Tree diagrams from these files.
      </t>
      <section anchor="platform-schema-mount">
        <name>YANG Tree Diagram of the Platform Manifest</name>
        <t>
          For the Platform Manifest, the extension data is provided in <xref target="platform-manifest-model"/> as "platform-extension-data.xml".
          The top-level YANG library is included below as "platform-toplevel-yanglib.xml".
          The following command was used to obtain the YANG Tree diagram (before manual edition).
        </t>
        <sourcecode type="bash">
yanglint -f tree \
  -x platform-extension-data.xml \
  -Y platform-toplevel-yanglib.xml \
  ietf-platform-manifest@2024-07-02.yang
        </sourcecode>
        <sourcecode anchor="platform-toplevel-yanglib" name="platform-toplevel-yanglib.xml" type="xml" markers="true"><![CDATA[
{{platform_toplevel_yanglib}}
]]>
        </sourcecode>
      </section>

      <section anchor="data-collection-schema-mount">
        <name>YANG Tree diagram of the Data Collection Manifest</name>
        <t>
          For the Data Collection Manifest, the extension data is provided in <xref target="module-code"/> as "data-collection-extension-data.xml".
          The top-level YANG library is included below as "data-collection-toplevel-yanglib.xml".
          The following command was used to obtain the YANG Tree diagram (before manual edition).
        </t>
        <sourcecode type="bash">
          yanglint -f tree \
          -x data-collection-extension-data.xml \
          -Y data-collection-toplevel-yanglib.xml \
          ietf-data-collection-manifest@2024-07-02.yang
        </sourcecode>
        <sourcecode anchor="data-collection-toplevel-yanglib" name="data-collection-toplevel-yanglib.xml" type="xml" markers="true"><![CDATA[
{{data_toplevel_yanglib}}
]]>
        </sourcecode>
      </section>
    </section>
    <section numbered="false">
      <name>Acknowledgements</name>
      <t>
          Thanks to Mohamed Boucadair, Tianran Zhou and Jan Lindblad for their reviews and comments.
       </t>
    </section>
  </back>
</rfc>
<!-- Local Variables: -->
<!-- fill-column:72 -->
<!-- End: -->