<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="4"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" ipr="trust200902" docName="draft-claise-opsawg-collected-data-manifest-02">
  <front>
    <title abbrev="Telemetry Data Manifest">A Data Manifest for Contextualized Telemetry Data</title>
    <author fullname="Benoit Claise" initials="B" surname="Claise">
      <organization>Huawei</organization>
      <address>
        <email>benoit.claise@huawei.com</email>
      </address>
    </author>
    <author fullname="Jean Quilbeuf" initials="J" surname="Quilbeuf ">
      <organization>Huawei</organization>
      <address>
        <email>jean.quilbeuf@huawei.com</email>
      </address>
    </author>
    <author fullname="Diego R. Lopez" initials="D" surname="Lopez ">
      <organization>Telefonica I+D</organization>
      <address>
        <postal>
          <street>Don Ramon de la Cruz, 82</street>
          <city>Madrid  28006</city>
          <country>Spain</country>
        </postal>
        <email>diego.r.lopez@telefonica.com</email>
      </address>
    </author>
    <author fullname="Ignacio Dominguez"  initials="I" surname="Dominguez">
      <organization>Universidad Politecnica de Madrid</organization>
      <address>
        <postal>
          <street>Avenida Complutense 30</street>
          <city>Madrid  28040</city>
          <country>Spain</country>
        </postal>
        <email>i.dominguezm@upm.es</email>
      </address>
    </author>
    <author fullname="Thomas Graf" initials="T. " surname="Graf">
      <organization>Swisscom</organization>
      <address>
        <postal>
          <street>Binzring 17</street>
          <city>Zurich</city>
          <code>8045</code>
          <country>Switzerland</country>
        </postal>
        <email>thomas.graf@swisscom.com</email>
      </address>
    </author>	  
    <date/>
    <area>OPS</area>
    <workgroup>OPSAWG</workgroup>
    <abstract>
      <t>
          Most network equipment feature telemetry as a mean to monitoring their status. 
		  Several protocols exist to this end, for example, the model-driven telemetry 
		  governed by YANG models. 
		  Some of these protocols provide the data itself, without any contextual information about the 
		  collection method. This can render the data unusable if that context is lost, for 
		  instance when the data is stored without the relevant information. This document proposes a data manifest, composed of two YANG data models, to store that contextual information along with the collected data, in order to keep the collected data exploitable in the future.
      </t>
    </abstract>
  </front>
  <middle>
    <section title="Terminology" anchor="terminology">
      <t>
         The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
         NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
         "MAY", and "OPTIONAL" in this document are to be interpreted as
         described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
         when, and only when, they appear in all capitals, as shown here.
      </t>
      <t>
        Data Manifest: all the necessary data required to interpret the telemetry information.
      </t>
      <t>
        Platform Manifest: part of the Data Manifest that completely characterizes the platform producing the data.
      </t>
      <t>
        Data Collection Manifest: part of the Data Manifest that completely characterizes how and when the telemetry 
        information was metered.
      </t>
    </section>
    <section anchor="intro" title="Introduction">
      <t>
        Network elements use Model-driven Telemetry (MDT) to continuously stream information, including both counters and state information.  
        This streamed information is used for network monitoring or closed-loop automation. 
        This streamed data can also be stored in a database (sometimes called a big data lake) for further analysis.
      </t>
      <t>
        When streaming YANG-structured data with YANG-Push <xref target="RFC8641"/>, there is a semantic definition in the corresponding YANG module definition.  On top of that definition, it is also important to maintain contextual information about the collection environment.
      </t>
      <t>
        As an example, a database could store a time series representing the evolution of a specific counter. 
        When analyzing the data, it is important to understand that this counter was requested from the network element at specific cadence, as this exact cadence might not be observed in the time series, potentially implying that the network element was under stress.
        The same time series might report some values as 0 or might even omit some values.  
        This might be explained by a too small observation period, compared to the minimum-observed-period <xref target="I-D.claise-netconf-metadata-for-collection"/>. 
        Again, knowing the conditions under which the counter was collected and streamed is crucial. 
        Indeed, taking into account the value of 0 might lead to a wrong conclusion that the counter dropped to zero.
        This document specifies the data collection manifest, which contains the required information to characterize how and when the telemetry information was metered.
      </t>
      <t>
        Precisely characterizing the source used for producing the data (that is the platform manifest) may also be useful to complete the data collection context. 
        As an example, knowing the exact data source software specification might reveal a particularity in the observed data, explained by a specific bug, or a specific bug fix. 
        This is also necessary to ensure the reliability of the collected data.
        On top of that, in particular for MDT, it is crucial to know the set of YANG modules supported by the device, along with their deviations. 
        In some cases, there might even be some backwards incompatible changes in native modules between one OS version to the next one. 
        This information must be compiled in a platform manifest.
      </t>
      <t>
         Some related YANG modules have been specified to retrieve the device capabilities:
        <list style="symbols">
          <t>
            <xref target="RFC9196"/> which models the device capabilities regarding the production and export of telemetry data.
          </t>
          <t>
            <xref target="I-D.claise-netconf-metadata-for-collection"/>, which is based on the previous draft to define the optimal settings to stream specific items (i.e., per path).
          </t>
        </list>
      </t>
      <t>
        While these related YANG modules are important to discover the capabilities before applying the telemetry configuration (such as on-change), some of their content is part of the context for the streamed data. The goal behind this specification is not to expose new information via YANG objects but rather to define what needs to be kept as metadata (the data manifest) to ensure that the collected data can still be interpreted correctly, even if the source device is not accesible (from the collection system), or if the device has been updated (new operating system or new configuration). 
        This manifest contains two parts, the platform manifest and the data collection manifest. 
        The platform manifest is "pretty" stable and should change only when the device is updated or patched. 
        On the other hand, the data collection manifest is likely to change each time a new MDT subscription is requested and might even change if the device load increases and collection periods are updated. 
        To separate these two parts, we enclose each of them in its own module. 
      </t>
      <t>
        We first present the module for the platform manifest in <xref target="platform-manifest"/> 
        and then the module for the data collection manifest in <xref target="data-collection-manifest"/>. 
        The full data manifest is obtained by combining these two modules. 
        We explain in <xref target="mapping" /> how the data-manifest can be collected and how collected data is mapped to the data manifest.
      </t>
    </section>
    <section anchor="platform-manifest" title="Platform Manifest">
        <section anchor="platform-manifest-model-tree" title="Overview of the model">
        <t>
          <xref target="platform-manifest-tree"/> contains the YANG tree diagram <xref target="RFC8340"/> of the ietf-collected-data-platform-manifest module.
            <figure anchor="platform-manifest-tree" title="YANG tree diagram for ietf-collected-data-platform-manifest module">
              <artwork><![CDATA[
module: ietf-collected-data-platform-manifest
  +--ro platform
     +--ro name?               string
     +--ro vendor?             string
     +--ro software-version?   string
     +--ro software-flavor?    string
     +--ro os-version?         string
     +--ro os-type?            string
     +--ro yang-library
     |  +--ro module-set* [name]
     |  |  +--ro name                  string
     |  |  +--ro module* [name]
     |  |  |  +--ro name              yang:yang-identifier
     |  |  |  +--ro revision?         revision-identifier
     |  |  |  +--ro namespace         inet:uri
     |  |  |  +--ro location*         inet:uri
     |  |  |  +--ro submodule* [name]
     |  |  |  |  +--ro name              yang:yang-identifier
     |  |  |  |  +--ro revision?         revision-identifier
     |  |  |  |  +--ro location*         inet:uri
     |  |  |  |  +--ro revision-label?   rev:revision-label
     |  |  |  +--ro feature*          yang:yang-identifier
     |  |  |  +--ro deviation*        -> ../../module/name
     |  |  |  +--ro revision-label?   rev:revision-label
     |  |  +--ro import-only-module* [name revision]
     |  |     +--ro name              yang:yang-identifier
     |  |     +--ro revision          union
     |  |     +--ro namespace         inet:uri
     |  |     +--ro location*         inet:uri
     |  |     +--ro submodule* [name]
     |  |     |  +--ro name              yang:yang-identifier
     |  |     |  +--ro revision?         revision-identifier
     |  |     |  +--ro location*         inet:uri
     |  |     |  +--ro revision-label?   rev:revision-label
     |  |     +--ro revision-label?   rev:revision-label
     |  +--ro schema* [name]
     |  |  +--ro name                            string
     |  |  +--ro module-set*
     |  |  |       -> ../../module-set/name
     |  |  +--ro deprecated-nodes-implemented?   boolean
     |  |  +--ro obsolete-nodes-absent?          boolean
     |  +--ro datastore* [name]
     |     +--ro name      ds:datastore-ref
     |     +--ro schema    -> ../../schema/name
     +--ro packages-set
        +--ro package* [name version]
           +--ro name        -> /pkgs:packages/package/name
           +--ro version     leafref
           +--ro checksum?   leafref
                ]]></artwork>
            </figure>
        </t>
          
          <t>
            The platform manifest contains a comprehensive set of  information characterize a data source.  
            The platform is identified by a set of parameters ('name', 'software-version', 'software-flavor', 'os-version', 'os-type') that are aligned with the YANG Catalog www.yangcatalog.org <xref target="I-D.clacla-netmod-model-catalog"/> so that the YANG catalog could be used to retrieve the YANG modules a posteriori.
          </t>
          <t>
            The platform manifest also includes the contents of the YANG Library <xref target="RFC8525"/>. 
            That module set is particularly useful to define the paths, as they are based on module names.
            Similarly, this module defines the available datastores, which can be referred to from the data-manifest, if necessary.
            If supported by the device, fetching metrics from a specific datastore could enable some specific use cases: monitoring configuration before it is committed, comparing between the configuration and operational datastore.
          </t>
          <t>
              Alternatively, the set of available YANG modules on the device can be described via packages-set which
              contains a list of references to YANG Packages <xref target="I-D.ietf-netmod-yang-packages"/>.
          </t>
        </section>
      <section anchor="platform-manifest-model" title="YANG module ietf-collected-data-platform-manifest">
        <t>&lt;CODE BEGINS&gt; file "ietf-collected-data-platform-manifest@2021-10-15.yang"</t>
        <figure>
          <artwork><![CDATA[
module ietf-collected-data-platform-manifest {
  yang-version 1.1;
  namespace
    "urn:ietf:params:xml:ns:yang:ietf-collected-data-platform-manifest";
  prefix p-mf;

  import ietf-yang-library {
    prefix yanglib;
    reference
      "RFC8525: YANG Library";
  }
  import ietf-yang-packages {
    prefix pkgs;
    reference
      "RFC  XXXX: YANG Packages.";
  }
  import ietf-yang-revisions {
    prefix rev;
    reference
      "XXXX: Updated YANG Module Revision Handling";
  }

  organization
    "IETF OPSAWG (Network Configuration) Working Group";
  contact
    "WG Web:   <https://datatracker.ietf.org/wg/opsawg/>
     WG List:  <mailto:opsawg@ietf.org>
     Author:   Benoit Claise  <mailto:benoit.claise@huawei.com>
     Author:   Jean Quilbeuf   <mailto:jean.quilbeuf@huawei.com>";
  description
    "This module describes the platform information to be used as
     context of data collection from a given network element. The
     contents of this model must be streamed along with the data
     streamed from the network element so that the platform context
     of the data collection can be retrieved later.

     The data content of this model should not change except on
     upgrade or patching of the device.

     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL',
     'SHALL NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED',
     'NOT RECOMMENDED', 'MAY', and 'OPTIONAL' in this document
     are to be interpreted as described in BCP 14 (RFC 2119)
     (RFC 8174) when, and only when, they appear in all
     capitals, as shown here.

     Copyright (c) 2022 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (https://trustee.ietf.org/license-info).
     This version of this YANG module is part of RFC XXXX; see the
     RFC itself for full legal notices.  ";

  revision 2021-10-15 {
    description
      "Initial revision";
    reference
      "RFC xxxx: Title to be completed";
  }

  // This is a copy-paste of the augments from the module
  // ietf-yang-library-revisions.
  // We just changed the path to which the data is added

  augment "/p-mf:platform/p-mf:yang-library/p-mf:module-set"
        + "/p-mf:module" {
    description
      "Add a revision label to module information";
    leaf revision-label {
      type rev:revision-label;
      description
        "The revision label associated with this module revision.
         The label MUST match the rev:revision-label value in the
         specific revision of the module loaded in this module-set.";
      reference
        "XXXX: Updated YANG Module Revision Handling;
         Section 5.2.1, Advertising revision-label";
    }
  }

  augment
    "/p-mf:platform/p-mf:yang-library/p-mf:module-set/p-mf:module/"
  + "p-mf:submodule" {
    description
      "Add a revision label to submodule information";
    leaf revision-label {
      type rev:revision-label;
      description
        "The revision label associated with this submodule revision.
         The label MUST match the rev:revision-label value in the
         specific revision of the submodule included by the module
         loaded in this module-set.";
      reference
        "XXXX: Updated YANG Module Revision Handling;
         Section 5.2.1, Advertising revision-label";
    }
  }

  augment "/p-mf:platform/p-mf:yang-library/p-mf:module-set/"
        + "p-mf:import-only-module" {
    description
      "Add a revision label to module information";
    leaf revision-label {
      type rev:revision-label;
      description
        "The revision label associated with this module revision.
         The label MUST match the rev:revision-label value in the
         specific revision of the module included in this module-set.";
      reference
        "XXXX: Updated YANG Module Revision Handling;
         Section 5.2.1, Advertising revision-label";
    }
  }

  augment "/p-mf:platform/p-mf:yang-library/p-mf:module-set/"
        + "p-mf:import-only-module/p-mf:submodule" {
    description
      "Add a revision label to submodule information";
    leaf revision-label {
      type rev:revision-label;
      description
        "The revision label associated with this submodule revision.
         The label MUST match the rev:label value in the specific
         revision of the submodule included by the
         import-only-module loaded in this module-set.";
      reference
        "XXXX: Updated YANG Module Revision Handling;
         Section 5.2.1, Advertising revision-label";
    }
  }

  augment "/p-mf:platform/p-mf:yang-library/p-mf:schema" {
    description
      "Augmentations to the ietf-yang-library module to indicate how
       deprecated and obsoleted nodes are handled for each datastore
       schema supported by the server.";
    leaf deprecated-nodes-implemented {
      type boolean;
      description
        "If set to true, this leaf indicates that all schema nodes with
         a status 'deprecated' are implemented
         equivalently as if they had status 'current'; otherwise
         deviations MUST be used to explicitly remove deprecated
         nodes from the schema.  If this leaf is absent or set to false,
         then the behavior is unspecified.";
      reference
        "XXXX: Updated YANG Module Revision Handling;
         Section 5.2.2, Reporting how deprecated and obsolete nodes
         are handled";
    }
    leaf obsolete-nodes-absent {
      type boolean;
      description
        "If set to true, this leaf indicates that the server does not
         implement any status 'obsolete' schema nodes.  If this leaf is
         absent or set to false, then the behaviour is unspecified.";
      reference
        "XXXX: Updated YANG Module Revision Handling;
         Section 5.2.2, Reporting how deprecated and obsolete nodes
         are handled";
    }
  }

  container platform {
    config false;
    description
      "Contains information about the platform that allows to identify
       and understand the individual data collection information.  ";
    leaf name {
      type string;
      description
        "Platform on which this module is implemented.";
    }
    leaf vendor {
      type string;
      description
        "Organization that implements that platform.";
    }
    leaf software-version {
      type string;
      description
        "Name of the version of software. With respect to most network
         device appliances, this will be the operating system version.
         But for other YANG module implementation, this would be a
         version of appliance software. Ultimately, this should
         correspond to a version string that will be recognizable by the
         consumers of the platform.";
    }
    leaf software-flavor {
      type string;
      description
        "A variation of a specific version where YANG model support
         may be different.  Depending on the vendor, this could be a
         license, additional software component, or a feature set.";
    }
    leaf os-version {
      type string;
      description
        "Version of the operating system using this module. This is
         primarily useful if the software implementing the module is an
         application that requires a specific operating system
         version.";
    }
    leaf os-type {
      type string;
      description
        "Type of the operating system using this module. This is
         primarily useful if the software implementing the module is an
         application that requires a specific operating system type.";
    }
    container yang-library {
      description
        "The YANG library of the device specifying the modules available
         in each of the datastores.";
      uses yanglib:yang-library-parameters;
    }
    container packages-set {
      description
        "Alternatively to module-set, use a list of yang packages to
         describe the list of available schema on the platform";
      uses pkgs:yang-ds-pkg-ref;
    }
  }
}
            ]]></artwork>
        </figure>
        <t>&lt;CODE ENDS&gt;</t>
      </section>
    </section>

     <section anchor="data-collection-manifest" title="Data Collection Manifest">
        <section anchor="model-tree" title="Overview of the model">
          <t>
            <xref target="collected-data-tree"/> contains the YANG tree diagram <xref target="RFC8340"/> of the ietf-collected-data-manifest module.
            <figure anchor="collected-data-tree" title="YANG tree diagram for ietf-collected-data-manifest module">
              <artwork><![CDATA[
module: ietf-collected-data-manifest
  +--ro data-collection
     +--ro mdt-subscriptions* [subscription-id]
        +--ro subscription-id           uint64
        +--ro datastore?                ds:datastore-ref
        +--ro mdt-path-data-manifest* [path]
           +--ro path                   yang:xpath1.0
           +--ro requested-period?      uint64
           +--ro actual-period?         uint64
           +--ro on-change?             boolean
           +--ro suppress-redundancy?   boolean
                ]]></artwork>
            </figure>
          </t>
          <t>
            The data-collection container contains the information related to individual items collection.
            This subtree currently contains only information about MDT collection.
            It could be extended and extendable to represent other kinds of data collection.
          </t>
          <t>
              MDT collection is organized in subscriptions.
              A given collector can subscribe to one ore more subscriptions that usually contain a list of paths.
              Such a collector only needs the data manifest for subscriptions it subscribed to.
              The data manifest for MDT is organized by subscriptions as well so that a collector can select only its subscriptions.
          </t>
          <t>
            We now have a chicken-and-egg issue if the collector collects the
            data-manifest via MDT and wants the data-manifest
            for the data-manifest subscription. First the
            collector will collect the actual paths that it needs in
            subscription A. Once it has the subscription id
            for A, it will need an additional subscription B for the data
            manifest of paths in A. Then, it would need
            another subscription C to fetch the data manifest for the
            subscription B and so on... A possible solution
            would be adding in the "mdt" container an
            additional list in that contains the data manifest for every
            path that is a data manifest.
            By including that list in subscription B, the collector would have
            the information about subscription B here.
          </t>
          <t>
            The "datastore" leaf of the subscription container specifies from which datastore the YANG paths are streamed.
          </t>
          <t>
            Within a given collection subscription, the granularity of the collection is defined by the path.
            Note that all devices do not support an arbitrary granularity up to the leaf, usually for performance reasons.
            Each path currently collected by the device should show up in the mdt-path-data-manifest list.
          </t>
          <t>
            For each path, the collection context must be specified including:
            <list style="symbols">
              <t> 'on-change': when set to true, an update is sent as soon as and only when a value changes. This is also known as Event-Driven Telemetry (EDT). When set to false, the values are sent regularly. </t>
              <t> 'suppress-redundancy' (only when 'on-change' is false): reduce bandwidth usage by sending a regular update only if the value is different from the previous update.</t>
              <t> 'requested-period' (only when 'on-change' is false): period between two updates requested by the client for this path</t>
              <t> 'actual-period' (only when 'on-change 'is false): actual period retained by the platform between two updates. That period could be larger than the requested one as the router can adjust it for performance reasons.</t>
            </list>
          </t>
          <t> 
            This information is crucial to understand the collected values. For instance, the 'on-change' and 'suppress-redundancy' options, if set, might remove a lot of messages from the database because values are sent only when there is a change.
          </t>
      </section>
      <section anchor="module-code" title="YANG module ietf-collected-data-manifest">
        <t>&lt;CODE BEGINS&gt; file "ietf-collected-data-manifest@2021-10-15.yang"</t>
        <figure>
          <artwork><![CDATA[
module ietf-collected-data-manifest {
  yang-version 1.1;
  namespace
    "urn:ietf:params:xml:ns:yang:ietf-collected-data-manifest";
  prefix data-manifest;

  import ietf-datastores {
    prefix ds;
    reference
      "RFC 8342: Network Management Datastore Architecture.";
  }
  import ietf-yang-types {
    prefix yang;
    reference
      "RFC 6991: Common YANG Data Types";
  }

  organization
    "IETF OPSAWG (Network Configuration) Working Group";
  contact
    "WG Web:   <https://datatracker.ietf.org/wg/opsawg/>
     WG List:  <mailto:opsawg@ietf.org>
     Author:   Benoit Claise  <mailto:benoit.claise@huawei.com>
     Author:   Jean Quilbeuf   <mailto:jean.quilbeuf@huawei.com>";
  description
    "This module describes the context of data collection from a
     given network element. The contents of this model must be
     streamed along with the data streamed from the network
     element so that the context of the data collection can
     be retrieved later.

     This module must be completed with
     ietf-collected-data-platform-manifest
     to capture the whole context of a data collection session.

     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL',
     'SHALL NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED',
     'NOT RECOMMENDED', 'MAY', and 'OPTIONAL' in this document
     are to be interpreted as described in BCP 14 (RFC 2119)
     (RFC 8174) when, and only when, they appear in all
     capitals, as shown here.

     Copyright (c) 2022 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (https://trustee.ietf.org/license-info).
     This version of this YANG module is part of RFC XXXX; see the
     RFC itself for full legal notices.  ";

  revision 2021-10-15 {
    description
      "Initial revision";
    reference
      "RFC xxxx: Title to be completed";
  }

  container data-collection {
    config false;
    description
      "Defines the information for each collected object";
    list mdt-subscriptions {
      key "subscription-id";
      description
        "Contains the list of current subscriptions on the
         local device. Enables the collector to select its own
         subscriptions in the list.";
      leaf subscription-id {
        type uint64;
        description
          "Id of the subscription generated by the telemetry emitter.
           The collector can use this id to retrieve information
           about the collection status for the corresponding paths.

           The type is inspired by openconfig-telemetry. TODO check if
           ietf has telemetry modules that we could leafref to.

           path to subscription id in openconfig:
           openconfig-telemetry:telemetry-system/subscriptions/
            persistent-subscriptions/persistent-subscription/state/oid";
      }
      leaf datastore {
        type ds:datastore-ref;
        description
          "The datastore from which the data for this subscription has
           been collected.";
      }
      list mdt-path-data-manifest {
        key "path";
        description
          "Status of the collection for the given path";
        leaf path {
          type yang:xpath1.0;
          description
            "The XPath context in which this XPath expression is
             evaluated is the datastore selected for the containing
             subscription object. If the datastore is not specified
             then the context is the operational datastore context.";
        }
        leaf requested-period {
          when "../on-change = 'false'";
          type uint64;
          description
            "Requested period, in millisecond, between two successive
             updates.";
        }
        leaf actual-period {
          when "../on-change = 'false'";
          type uint64;
          description
            "Period in milisecond between two successive updates
             actually applied by the plaftorm at configuration time.
             This period can be larger than the requested period as the
             platform might adjust it for performance reasons.";
        }
        leaf on-change {
          type boolean;
          description
            "Whether the path is collected only when there is a
             change, i.e. Event-Driven Telemetry is enabled.";
        }
        leaf suppress-redundancy {
          type boolean;
          description
            "Whether the information is sent at every period or only
             when there is a change between two successive pollings.";
        }
      }
      // we could augment here with other kind of collection items
    }
  }
}
    ]]></artwork>
        </figure>
        <t>&lt;CODE ENDS&gt;</t>
      </section>
    </section>
    <section anchor="mapping" title="Collecting Data Manifest and Mapping Data to Data Manifest">
      <t>
          The data manifest MUST be streamed all with the data and stored along with the collected data. 
          In case the collected data are moved to a different place (typically a database), the data manifest MUST follow the collected data.
          This can render the data unusable if that context is lost, for instance when the data is stored without the relevant information.
		      The data manifest MUST be updated when the data manifest information changes (for example, when a router is upgraded), when a new telemetry subscription is configured, or when the telemetry subscription paremeters change.
      </t>
       <t>
          The data should be mapped to the data manifest. Since the data manifest will not change as frequently as the data itself, it makes sense to map several data to the same data manifest. Somehow, the collected data must include a metadata pointing to the corresponding data manifest.
       </t>
       <t>
          The platform manifest is likely to remain the same until the device is updated. So, the platform manifest only needs to be collected once per streaming session and updated after a device reboot.
       </t>
        <t>
          As this draft specifically focuses on giving context on data collected via streamed telemetry, we can assume that a streaming telemetry system is available.
          Collecting the data and platform manifests can be done either by reusing that streaming telemetry system (in-band) or using another system (out-of-band), for instance by adding headers or saving manifests into a YANG instace file <xref target="RFC9195"/>.
        </t>
        <t>
          We propose to reuse the existing telemetry system (in-band approach) in order to lower the efforts for implementing this draft.
          To enable a platform supporting streaming telemetry to also support data collection manifests, it is sufficient that this device supports
          the models from <xref target="platform-manifest"/> and <xref target="data-collection-manifest"/>.
          Recall that each type of manifest has its own rough frequency update, i.e. at reboot for the platform manifest and at new subscription or CPU load variation for the data collection manifest.
          The data manifest MUST be streamed with the YANG-Push on-change feature <xref target="RFC8641"/> (also called event-driven telemetry).
        </t>
      <section anchor="mapping_dm" title="Mapping Collected Data to the Data Manifest">
        <t>
             With MDT, a particular datapoint is always associated to a path that is itself part of a subscription.
             In order to enable a posteriori retrieval of the data manifest associated to a datapoint, the collector must:
             <list style="symbols">
                 <t>keep the path in the metadata of the collected values</t>
                 <t>collect as well the data-manifest for the subscription and path associated to the datapoint.</t>
             </list>
             With this information, to retrieve the data manifest from the datapoint, the following happens:
             <list style="symbols">
                 <t>the path is retrieved from the datapoint metadata</t>
                 <t>the data-manifest for that path is retrieved by looking up on the collected data-manifest.</t>
             </list>
         </t>
         <t>
             In that scenario, the reliability of the collection of the data manifest is the same as the reliability of the data collection itself, since the data manifest is like any other data.
             For telemetry based on gRPC for instance, a disconnection to the server would be detected as the HTTP connection would fail.
         </t>
      </section>
    </section>
    <section anchor="example" title="Example">
      <t> Below is an example of a data-manifest file:</t>
      <t>&lt;CODE BEGINS&gt; file "ietf-collected-data-manifest@2021-10-15.yang"</t>
      <figure>
        <artwork><![CDATA[
{
  "ietf-yang-instance-data:instance-data-set": {
    "name": "data-manifest-example",
    "content-schema": {
      "module": "ietf-collected-data-manifest@2021-10-15"
    },
    "timestamp": "2022-02-24T09:45:03Z",
    "description": [
      "Data manifest for the subscription 4242"
    ],
    "content-data": {
      "ietf-collected-data-manifest:data-collection": {
        "mdt-subscriptions": [
          {
            "subscription-id": 4242,
            "mdt-path-data-manifest": [
              {
                "path": "/ietf-interfaces:interfaces/interface/enabled",
                "requested-period": 100,
                "current-period": 10000,
                "on-change": false,
                "suppress-redundancy": false
              },
              {
                "path": "/ietf-interfaces:interfaces/interface/statistics/in-octets",
                "requested-period": 100,
                "current-period": 100,
                "on-change": false,
                "suppress-redundancy": false
              }
            ]
          }
        ]
      }
    }
  }
}
  ]]></artwork>
      </figure>
      <t>&lt;CODE ENDS&gt;</t>
      <t>
        The file above contains the data manifest for paths collected in the subscription with id 4242.
        The requested period for both path is this subscription was 100ms, however the status of the interface could only be collected every 10s.
      </t>

    </section>
    <section anchor="security" title="Security Considerations">
      <t>
        As we are reusing an existing telemetry system, the security considerations lies with the new content divulged in the new manifests.
        Appropriate access control must be associated to the corresponding leafs and containers.
      </t>
    </section>
    <section anchor="iana" title="IANA Considerations">
      <t>
        This document includes no request to IANA.
      </t>
    </section>
    <section title="Contributors">
    </section>
    <section title="Open Issues">
      <t>
        <list style="symbols">
	  <t> 
            Do we want to the hardware specifications, next to the OS information? How to fully characterize a virtual device? Do we need to include the vendor (as PEN for instance https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers) ?
          </t>
          <t> 
            Do we want to handle the absence of values, i.e. add information about missed collection or errors in the collection context ? It could also explain why some values are missing. On the other hand, this might also be out scope.
          </t>
          <t>
            How do we handle other kinds of collection than MDT like netflow, SNMP, CLI ? How do we map the collected data to the data-manifest ?
          </t>
          <t>
            Align the terms with the YANG Push specifications. Ex: path to subscription (TBC)
          </t>
          <t>
            Better explain the on-change example.
          </t>
          <t>
            Regarding the inclusion of ietf-yang-library in our module, do we want to include as well the changes from ietf-yang-library-revisions? What if other information are present in the yang-libary from the platform? Should we use a YANG mount to capture them as well (they would not be captured with our use of the main yang-library grouping).
          </t>
          <t>
            Henk: how does this interact with SBOM effort?
          </t>
          <t>
            Eliot: important to give integrity of the information a lot of thought. Threat model to be considered.
          </t>
        </list>
      </t>
    </section>
  </middle>
  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.2119"?>
      <?rfc include="reference.RFC.8174"?>
      <?rfc include="reference.RFC.8340"?>
      <?rfc include="reference.RFC.8525"?>
      <?rfc include="reference.RFC.8641"?>
      <?rfc include="reference.RFC.9195"?>
    </references>
    <references title="Informative References">
      <?rfc include="reference.I-D.draft-clacla-netmod-model-catalog-03"?>
      <?rfc include="reference.I-D.draft-claise-netconf-metadata-for-collection-02"?>
      <?rfc include="reference.RFC.9196"?>
      <?rfc include="reference.I-D.ietf-netmod-yang-packages"?>
    </references>
    <?rfc needLines="100"?>
    <section title="Changes between revisions">
      <t>
        Version 3
        <list>
          <t> Add when clause in YANG model</t>
        </list>
      </t>
      <t>
        Version 2
        <list>
          <t> Alignment with YANGCatalog YANG module: name, vendor </t>
          <t> Clarify the use of YANG instance file </t>
          <t> Editorial improvements </t>
          <t> </t>
        </list>
      </t>
      <t>
        Version 1 
        <list>
          <t> Adding more into data platform: yang packages, whole yanglib module to specify datastores </t>
          <t> Setting the right type for periods: int64 -> uint64 </t>
          <t> Specify the origin datastore for mdt subscription </t>
          <t> Set both models to config false </t>
          <t> Applying text comments from Mohamed Boucadair </t>
          <t> Adding an example of data-manifest file </t>
          <t> Adding rationale for reusing telemetry system for collection of the manifests </t>
          <t> Export manifest with on change telemetry as opposed to YANG instance file </t>
          <t> </t>
        </list>
      </t>
      <t> 
        Version 0
          <list>
          <t> Initial version </t>
          <t> </t>
        </list>
      </t>
    </section>
    <section title="Acknowledgements" numbered="no">
      <t>
          Thanks to Mohamed Boucadair and Tianran Zhou for their reviews and comments.
       </t>
    </section>
  </back>
</rfc>
<!-- Local Variables: -->
<!-- fill-column:72 -->
<!-- End: -->